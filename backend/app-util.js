'use strict';



var bcrypt = require('bcrypt');

/**
 * utility namespace
 * @namespace utility  
 * @property {Library}                      Puid              Puid library
 * @property {Library}                      async             async library
 *
 * @property {function}                     printData         custome function that prints mesage in the console
 * @property {function}                     printError        custome function that prints error in the console    
 *
 * @property {CustomDate}                   helperDate        instance of CustomDate Class
 * @property {Utility}                      misc              instance of Utility Class 
 * @property {Message}                      message           instance of Message Class
 * @property {language.getMessage}          getLang           acquiring client language 
 * @property {module:Workflow}              workflow          acquiring the workflow
 */

var utility = {
  handleFile: require('./util/ex-file-handle'),
  imageHandle: require('./util/image-handle'),
  Puid: require('puid'),
  async: require('async'),
  printData: console.log,
  printError: console.error,
  helperDate: require('./util/helper-date'),
  misc: require('./util/custom-array-object'),
  message: require('./util/message'),
  getLang: require('./util/client-message'),
  workflow: require('./util/workflow'),
  pushNotification: require('./util/push-notification'),
  slugify: require('./util/slugify'),
  sendmail: require('./util/sendmail'),
  request: require('request')
};

/**
 * check params to be an mongoose Id or not
 * @memberOf utility
 */
utility.validateMongooseId = function(paramString) {
  return function(req, res, next) {
    if (!req.params) {
      next();
    }
    if (!req.params[paramString] ||
      req.params[paramString].toString().length !== 24) {
      req.workflow.outcome.errfor[paramString] =
        req.app.utility.message.INVALID(paramString);
      return req.workflow.emit('response');
    }
    next();
  };
};

/**
 * generate a unique name
 * @return {String}             return a unique name generated by using puid library
 * @memberOf utility
 */
utility.generateUniqKey = function() {
  var puid = new utility.Puid();
  return puid.generate();
};

/**
 * this function generates a standard access control object
 * @param  {object}   res                         response object
 * @param  {Function} next                        next queued function                         
 * @return {utility.getCallbacksResponse}         return of this function
 *
 * @memberOf utility
 */
utility.getCallbacks = function(res, next) {
  return {
    allowed: next,
    denied: function() {
      res.status(403);
      res.send();
    },
    notfound: function() {
      res.status(404);
      res.send();
    },
    invalid: function() {
      res.status(405);
      res.send();
    }
  };

};

/**
 * this function checks whether the request is authenticated or session is found or not
 * if the session is found then this function increase the age of the session and remove 
 * the previous session. If the previous session is not found then this function set the 
 * response header. This function uses utility.getCallbacks method to send the response 
 * or for tthe further processing
 * 
 * @param  {object}   req                         request object
 * @param  {function} req.isAuthenticated         method to check the authentication 
 *                                                or simply session
 * @param  {object}   req.session                 session object
 * @param  {Date}     req.session._garbage        to remove previous session
 * @param  {function} req.session.touch           to increase the age of the  previous session
 * 
 * @param  {object}   res                         response object
 * @param  {Function} next                        next queued function                         
 *
 * @memberOf utility
 */
utility.ensureAuthenticated = function(req, res, next) {
  var cb = utility.getCallbacks(res, next);
  if (req.isAuthenticated()) {
    req.session._garbage = Date();
    req.session.touch();
    return cb.allowed();
  } else {
    res.set('X-Auth-Required', 'sessionDestroyed');
    cb.denied();
  }
};


/**
 * this function checks whether the request is by super-user or not.
 * 
 * @param  {object}   req                         request object
 * @param  {function} req.isAuthenticated         method to check the authentication 
 *                                                or simply session
 * @param  {object}   req.session                 session object
 * @param  {Date}     req.session._garbage        to remove previous session
 * @param  {function} req.session.touch           to increase the age of the  previous session
 * 
 * @param  {object}   res                         response object
 * @param  {Function} next                        next queued function                         
 *
 * @memberOf utility
 */
utility.checkSuperUser = function(req, res, next) {
  var cb = utility.getCallbacks(res, next);
  if (req.user.usertype === req.app.config.User.defaultSuper) {
    return cb.allowed();
  } else {
    cb.denied();
  }
};


/**
 * if req.query has a lang property this function used it to set the lang 
 * otherwise
 * this function attachs the user's preferred language or default language to 
 * the req.query object in lang property
 * if user's preferred language is not found then it will attach then it will 
 * attach the default  language stored in config object of app namespace
 * 
 * @param  {object}   req                               request object 
 * @param  {object}   req.query                         query object of request object
 * @param  {object}   [req.query.lang]                  supplied lang variable
 * @param  {object}   [req.user]                        sessioned user object of request object
 * @param  {object}   [req.user.preferredLanguage]      preferred language of the user 
 * @param  {app}      req.app                           app namespace
 * @param  {Object}   req.app.config                    default config object
 * @param  {Object}   req.app.config.defaultLanguage    default language that needs to be atatched
 * @param  {object}   res                               response object
 * @param  {Function} next                              next queued function 
 * @memberOf utility
 */
utility.addDefaultLanguage = function(req, res, next) {
  if (!req.query.lang) {
    if (req.user && req.user.preferredLanguage) {
      req.query.lang = req.user.preferredLanguage;
    } else {
      req.query.lang = req.app.config.defaultLanguage;
    }
  }
  next();
};

/**
 * this function attachs the workflow instance to each request obejct and execute the next queued function
 * @param  {object}   req    request object 
 * @param  {object}   res    response object
 * @param  {Function} next   next queued function 
 * @memberOf utility
 */
utility.attacheWorkflow = function(req, res, next) {
  req.workflow = req.app.utility.workflow(req, res);
  next();
};

/**
 * this function generate the encrypted password over the set password
 * @param  {String}         password    password of the manager
 * @param {requestCallback} done        callback to be executed after the find operation
 * @function .encryptPassword
 * @memberOf utility
 */
utility.encryptPassword = function(password, done) {
  bcrypt.genSalt(10, function(err, salt) {
    if (err) {
      return done(err);
    }

    bcrypt.hash(password, salt, function(err, hash) {
      done(err, hash);
    });
  });
};

/**
 * this function matches the password and return whether the password matches or not
 * @param  {String}          password    passowrd of the manager
 * @param  {String}          hash        encrypted passowrd
 * @param  {requestCallback} done        callback to be executed after the find operation
 * @function .validatePassword
 * @memberOf utility
 */
utility.validatePassword = function(password, hash, done) {
  bcrypt.compare(password, hash, function(err, res) {
    done(err, res);
  });
};

/**
 * this function matches the password and return whether the password matches or not
 * @param  {object}   req    request object 
 * @param  {object}   res    response object
 * @param  {Function} next   next queued function
 * @function .checkEmail
 * @memberOf utility
 */
utility.checkEmail = function(collection) {

  return function(req, res, next) {

    if (!req.app.config.User.emailRegExp.test(req.body.email)) {
      req.workflow.outcome.errfor.email =
        req.app.utility.message.INVALID('email');
      return req.workflow.emit('response');
    }

    var query = {
      email: req.body.email
    };

    if (req.partner) {
      query._id = {
        $ne: req.partner._id
      };
    }

    req.app.db.models[collection]
      .count(query)
      .exec(function(err, data) {
        if (err) {
          return next(err);
        }
        if (data) {
          req.workflow.outcome.errfor.email =
            req.app.utility.getLang('EMAIL_TAKEN', req.query.lang);
          return req.workflow.emit('response');
        } else {
          return next();
        }
      });
  };
};

/** 
    @typedef decodeBase64StringResponse
    @memberof utility
    @type {Object} 
    @property {String} type         mime type of the image
    @property {String} extension    extension of the base64 image
    @property {Buffer} data         equivalent Buffer data of the base64 image
  */

/**
 * check the bas64String and validate whether the string is image or not
 * @param  {String}                                 dataString  base64 string
 * @return {utility.decodeBase64StringResponse}     iff the image is valid then response of the base64Image
 * @return {String}                                 otherwise return a string
 * @memberOf utility
 */
utility.decodeBase64Image = function(dataString) {
  var response = {},
    matches = dataString.match(/^data:([A-Za-z-+/]+);base64,(.+)$/),
    mimes = {
      'image/jpeg': 'jpeg',
      'image/jpg': 'jpg',
      'image/png': 'png',
    };

  if (!matches || matches.length !== 3) {
    return 'Invalid input string';
  }

  response.type = matches[1];
  response.extension = mimes[matches[1]];
  response.data = new Buffer(matches[2], 'base64');

  if (!response.extension) {
    return 'Invalid image';
  }

  return response;
};

/** 
  @typedef makeImageFrombase64Response
  @memberof utility
  @type {Object} 
  @property {String} url         url of the generated image
  @property {String} key         name of the image
*/
/**
 * generate an image with the configuration object and return the path and name of the key
 * @param  {object} config                              configuration object
 * @param  {String} config.destinationPath              destination path where the image should created
 * @param  {String} config.fileName                     fileName string
 * @param  {String} config.name                         uniq name of the image file
 *
 * @return {utility.makeImageFrombase64Response}        iff the image operation is successful
 * @return {Error}                                      otherwise return a error object
 * @memberOf utility
 */
utility.moveFile = function(config) {

  var key = config.name + '.' +
    config.fileName.split('.')[1];

  var path = config.destinationPath +
    '/' + key;

  console.log(config, path);

  utility.handleFile.fs.mkdirsSync(config.destinationPath);
  utility.handleFile.fs.copySync(config.fileName, path);
  return {
    url: path,
    key: key
  };

};

/**
 * upload a file into an amazon bucket
 * @param  {object}           config                    configuration object
 * @param  {String}           config.bucket             name of the bucket object
 * @param  {String}           config.key                name of the item inside this bucket
 * @param  {String}           config.path               path of the file
 * @param  {requestCallback}  callback                  The callback that handles the response.
 * @return {String}                                     url of the uplaoded file as a data of requestCallback and null as err
 * @return {Error}                                      otherwise return a error object as a err of requestCallback and null as data
 * @memberOf utility
 */
utility.uploadFile = function(config, callback) {

  // return callback(null, utility.s3Util.getUrl({
  //   bucket: config.bucket,
  //   key: config.key
  // }));

  utility.s3Util.uploadInS3({
    bucket: config.bucket,
    key: config.key,
    path: config.path,
    ACL: 'public-read'
  }, function(err) {
    if (err) {
      callback(err);
    } else {
      callback(null, utility.s3Util.getUrl({
        bucket: config.bucket,
        key: config.key
      }));
    }
  });

};

/** 
    @typedef uploadBase64ImageResponse
    @memberof utility
    @type {Object} 
    @property {String}    url           url of the image that is saved in the s3
    @property {String}    key           key of the image that is saved in s3
    @property {String}    bucket        name of the bucket where the image is saved 
  */

/**
 * upload a file into an amazon bucket
 * @param  {object}           req                       request object
 * @param  {Object}           req.workflow              workflow instance
 * @param  {Object}           req.app                   app namespace
 * @param  {Object}           req.app.config            app namespace
 *
 * @param  {object}           res                       response object
 *
 * @param  {object}           config                    configuration object
 * @param  {String}           config.path               path of the image where we can create th image and process
 * @param  {String}           config.bucket             bucket property to store the image
 * @param  {String}           config.filePath           original path property from multiparty
 * @param  {requestCallback}  callback                  The callback that handles the response.
 *
 * @return {util.uploadBase64ImageResponse}             if the operation is successfull this will be return as suceess.
 *                                                      if fromLibrary flag is true then bucket and key flag will be ommitted
 *
 * @fires  module:Workflow~response if found any error
 *
 * @memberOf utility
 */
utility.uploadFileInS3 = function(req, res, next, config, cb) {

  var response = utility.moveFile({
    destinationPath: config.path,
    name: utility.generateUniqKey(),
    fileName: config.filePath
  });

  utility.handleFile.validFile({
    path: response.url,
    validMime: config.mime
  }, function(err, data) {
    if (err) {
      utility.handleFile.removeFile(response.url);
      return next(err);
    }

    if (!data) {
      utility.handleFile.removeFile(response.url);
      req.workflow.outcome.errfor.type = req.app.utility.getLang('INVALID_FILE', req.query.lang);
      return req.workflow.emit('response');
    }

    if (!config.bucket) {
      throw new Error('no bucket property found in uploadBase64Image property');
    }

    utility.uploadFile({
      bucket: config.bucket,
      key: response.url, //response.key,//fix it to upload the path
      path: response.url,
    }, function(err, data) {
      utility.handleFile.removeFile(response.url);
      if (err) {
        return next(err);
      } else {
        cb({
          url: data,
          bucket: config.bucket,
          key: response.key
        });
      }
    });
  });
};

/**
 * remove a profile picture from amazon s3 bucket
 * @param  {object} config                    configuration object
 * @param  {String} [config.bucket]           name of the bucket object
 * @param  {String} [config.key]              name of the item inside this bucket
 * @param  {requestCallback} callback         The callback that handles the response.
 * @return {Boolean}                          always return true as a data of requestCallback and null as err
 * @memberOf utility
 */
utility.removeFileFromS3 = function(link, callback) {
  console.log("link----", link);
  link = link.substr(link.indexOf('//') + 2);


  utility.s3Util.removeObject({
    key: link.substr(link.indexOf('/') + 1),
    bucket: link.substr(0, link.indexOf('.'))
  }, function() {
    callback(null, true);
  });

};


utility.removeMultipleFilesFromS3 = function(links, callback) {
  var deleteObject = {
    Objects: []
  };
  var object = {};

  var temp1 = links[0].substr(links[0].indexOf('//') + 2);
  var bucket = temp1.substr(0, temp1.indexOf('.'));


  links.forEach(function(link) {
    var temp = link.substr(link.indexOf('//') + 2);
    object.Key = temp.substr(temp.indexOf('/') + 1);
    deleteObject.Objects.push(object);
    object = {};
  });

  utility.s3Util.removeMultipleObjects({
    delete: deleteObject,
    bucket: bucket
  }, callback);

};



module.exports = utility;
